From 7588a8188f390e1dc4a324adf94474ebf2bc7f17 Mon Sep 17 00:00:00 2001
From: Christophe Chapuis <chris.chapuis@gmail.com>
Date: Mon, 27 Feb 2017 19:17:28 +0000
Subject: [PATCH] tests: make test_camera use wayland

Signed-off-by: Christophe Chapuis <chris.chapuis@gmail.com>
---
 hybris/tests/Makefile.am   |   4 +-
 hybris/tests/test_camera.c | 109 ++++++++++++++++++++++++++++++++++++-
 2 files changed, 109 insertions(+), 4 deletions(-)

diff --git a/hybris/tests/Makefile.am b/hybris/tests/Makefile.am
index 242436b..cfba29c 100644
--- a/hybris/tests/Makefile.am
+++ b/hybris/tests/Makefile.am
@@ -152,13 +152,13 @@ test_camera_SOURCES = test_camera.c
 test_camera_CFLAGS = \
 	-I$(top_srcdir)/include \
 	$(ANDROID_HEADERS_CFLAGS)
-
 test_camera_LDADD = \
 	$(top_builddir)/common/libhybris-common.la \
 	$(top_builddir)/egl/libEGL.la \
 	$(top_builddir)/glesv2/libGLESv2.la \
 	$(top_builddir)/camera/libcamera.la \
-	$(top_builddir)/input/libis.la
+	$(top_builddir)/input/libis.la \
+	$(top_builddir)/egl/platforms/common/libwayland-egl.la -lwayland-client
 
 test_media_SOURCES = test_media.c
 test_media_CFLAGS = \
diff --git a/hybris/tests/test_camera.c b/hybris/tests/test_camera.c
index 693a6fb..d52d9f5 100644
--- a/hybris/tests/test_camera.c
+++ b/hybris/tests/test_camera.c
@@ -17,6 +17,11 @@
 
 #include "config.h"
 
+#include <wayland-client.h>
+#include <wayland-server.h>
+#include <wayland-client-protocol.h>
+#include <wayland-egl.h>
+
 #include <hybris/camera/camera_compatibility_layer.h>
 #include <hybris/camera/camera_compatibility_layer_capabilities.h>
 
@@ -246,6 +251,7 @@ static GLuint loadShader(GLenum shaderType, const char* pSource) {
 	return shader;
 }
 
+
 static GLuint create_program(const char* pVertexSource, const char* pFragmentSource) {
 	GLuint vertexShader = loadShader(GL_VERTEX_SHADER, pVertexSource);
 	if (!vertexShader) {
@@ -286,6 +292,76 @@ static GLuint create_program(const char* pVertexSource, const char* pFragmentSou
 	return program;
 }
 
+
+struct wl_display *wldisplay = NULL;
+struct wl_compositor *wlcompositor = NULL;
+struct wl_surface *wlsurface;
+struct wl_egl_window *wlegl_window;
+struct wl_region *wlregion;
+struct wl_shell *wlshell;
+struct wl_shell_surface *wlshell_surface;
+
+static void
+global_registry_handler(void *data, struct wl_registry *registry, uint32_t id,
+	       const char *interface, uint32_t version)
+{
+    printf("Got a registry event for %s id %d\n", interface, id);
+    if (strcmp(interface, "wl_compositor") == 0) {
+        wlcompositor = wl_registry_bind(registry, 
+				      id, 
+				      &wl_compositor_interface, 
+				      1);
+    } else if (strcmp(interface, "wl_shell") == 0) {
+	wlshell = wl_registry_bind(registry, id,
+				 &wl_shell_interface, 1);
+	
+    }
+}
+
+static void
+global_registry_remover(void *data, struct wl_registry *registry, uint32_t id)
+{
+    printf("Got a registry losing event for %d\n", id);
+}
+
+static const struct wl_registry_listener registry_listener = {
+    global_registry_handler,
+    global_registry_remover
+};
+
+static void
+get_server_references(void) {
+
+    wldisplay = wl_display_connect(NULL);
+    if (wldisplay == NULL) {
+	fprintf(stderr, "Can't connect to display\n");
+	exit(1);
+    }
+    printf("connected to display\n");
+
+    struct wl_registry *registry = wl_display_get_registry(wldisplay);
+    wl_registry_add_listener(registry, &registry_listener, NULL);
+
+    wl_display_dispatch(wldisplay);
+    wl_display_roundtrip(wldisplay);
+
+    if (wlcompositor == NULL || wlshell == NULL) {
+	fprintf(stderr, "Can't find compositor or shell\n");
+	exit(1);
+    } else {
+	fprintf(stderr, "Found compositor and shell\n");
+    }
+}
+
+static void
+create_opaque_region() {
+    wlregion = wl_compositor_create_region(wlcompositor);
+    wl_region_add(wlregion, 0, 0,
+		  1024,
+		  1024);
+    wl_surface_set_opaque_region(wlsurface, wlregion);
+}
+
 int main(int argc, char** argv)
 {
 	struct CameraControlListener listener;
@@ -356,6 +432,22 @@ int main(int argc, char** argv)
 	FocusRegion fr = { top: -200, left: -200, bottom: 200, right: 200, weight: 300};
 	android_camera_set_focus_region(cc, &fr);
 
+	/* Wayland Setup */
+	get_server_references();
+   
+	wlsurface = wl_compositor_create_surface(wlcompositor);
+	if (wlsurface == NULL) {
+	    fprintf(stderr, "Can't create surface\n");
+	    exit(1);
+	} else {
+	    fprintf(stderr, "Created surface\n");
+	}
+
+	wlshell_surface = wl_shell_get_shell_surface(wlshell, wlsurface);
+	wl_shell_surface_set_toplevel(wlshell_surface);
+	
+	create_opaque_region();
+
 	/* EGL Setup */
 	EGLConfig ecfg;
 	EGLBoolean rv;
@@ -372,7 +464,7 @@ int main(int argc, char** argv)
 		EGL_NONE
 	};
 
-	EGLDisplay disp = eglGetDisplay(NULL);
+	EGLDisplay disp = eglGetDisplay((EGLNativeDisplayType)wldisplay);
 	assert(eglGetError() == EGL_SUCCESS);
 	assert(disp != EGL_NO_DISPLAY);
 
@@ -384,8 +476,16 @@ int main(int argc, char** argv)
 	assert(eglGetError() == EGL_SUCCESS);
 	assert(rv == EGL_TRUE);
 
+	wlegl_window = wl_egl_window_create(wlsurface, 1024, 1024);
+	if (wlegl_window == EGL_NO_SURFACE) {
+	    fprintf(stderr, "Can't create egl window\n");
+	    exit(1);
+	} else {
+	    fprintf(stderr, "Created egl window\n");
+	}
+	
 	EGLSurface surface = eglCreateWindowSurface((EGLDisplay) disp, ecfg,
-			(EGLNativeWindowType) NULL, NULL);
+			(EGLNativeWindowType) wlegl_window, NULL);
 	assert(eglGetError() == EGL_SUCCESS);
 	assert(surface != EGL_NO_SURFACE);
 
@@ -473,5 +573,10 @@ int main(int argc, char** argv)
 		glDisableVertexAttribArray(gaTexHandle);
 
 		eglSwapBuffers((EGLDisplay) disp, surface);
+		
+		wl_display_dispatch(wldisplay);
 	}
+    
+    wl_display_disconnect(wldisplay);
+    
 }
